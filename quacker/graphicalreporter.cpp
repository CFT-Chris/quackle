/*
 *  Quackle -- Crossword game artificial intelligence and analysis tool
 *  Copyright (C) 2005-2014 Jason Katz-Brown and John O'Laughlin.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include <QString>
 
#include "board.h"
#include "computerplayer.h"
#include "game.h"
#include "quackleio/util.h"

#include "graphicalboard.h"
#include "graphicalreporter.h"

const char *kHtmlHeader =
"<html>\n"
"<head>\n"
"<title>Quackle Graphical Game Report</title>\n"
"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf8\">\n"
"</head>\n"
"<body bgcolor=white>\n"
"<h1>Graphical Game Report</h1>\n"
"<p><i>Generated by Quackle crossword game AI and analysis software</i>\n"
"<br /><a href=\"http://quackle.org\">http://quackle.org</a></p>\n"
"\n\n"
;

GraphicalReporter::GraphicalReporter(const string &filename)
	: m_ostream(filename)
{
}

void GraphicalReporter::reportHeader(const Quackle::Game &game)
{
	m_ostream << kHtmlHeader;
	m_ostream << game.currentPosition().board().htmlKey();
}

void GraphicalReporter::reportGame(const Quackle::Game &game, Quackle::ComputerPlayer *computerPlayer)
{
	reportHeader(game);

	for (Quackle::PositionList::const_iterator it = game.history().begin(); it != game.history().end(); ++it)
	{
		reportPosition(*it, computerPlayer);
	}
}

void GraphicalReporter::reportPosition(const Quackle::GamePosition &position, Quackle::ComputerPlayer *computerPlayer)
{
	Quackle::GamePosition positionCopy = position;

	{
		string title;

		if (!position.gameOver())
		{
			m_ostream << "<h2>" << position.currentPlayer().name() << ": Turn " << position.turnNumber() << "</h2>";
		}
		else
		{
			m_ostream << "<h2>Game over.</h2>";
		}

		const int boardTileSize = position.gameOver()? 45 : 25;
		m_ostream << string(QuackleIO::Util::sanitizeUserVisibleLetterString(QuackleIO::Util::uvStringToQString(position.board().htmlBoard(boardTileSize))).toUtf8().constData()) << endl;
	}

	const Quackle::PlayerList players(position.endgameAdjustedScores());

	m_ostream << "<table cellspacing=6>" << endl;
	for (Quackle::PlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
	{
		m_ostream << "<tr>";

		m_ostream << "<td>";
		if ((*it) == position.currentPlayer())
			m_ostream << "&rarr;";
		else
			m_ostream << "&nbsp;";
		m_ostream << "</td>";

		m_ostream
		<< "<td>" << (*it).name() << "</td>"
		<< "<td>" << string(QuackleIO::Util::sanitizeUserVisibleLetterString(QuackleIO::Util::uvStringToQString((*it).rack().toString())).toUtf8().constData()) << "</td>"
		<< "<td>" << (*it).score() << "</td>"
		<< "</tr>"
		<< endl;
	}
	m_ostream << "</table>" << endl;

	if (computerPlayer && !position.gameOver())
	{
		computerPlayer->setPosition(position);

		if (position.committedMove().isAMove())
			computerPlayer->considerMove(position.committedMove());

		const unsigned int movesToShow = 5;
		Quackle::MoveList moves = computerPlayer->moves(movesToShow);

		if (!moves.contains(position.committedMove()))
		{
			if (moves.size() == movesToShow)
				moves.pop_back();

			moves.push_back(position.committedMove());
		}

		m_ostream << "<ol>" << endl;
		for (Quackle::MoveList::const_iterator it = moves.begin(); it != moves.end(); ++it)
		{
			QString item;
			switch ((*it).action)
			{
			case Quackle::Move::Place:
			{
				item = "%1 %2";
				item = item.arg(QuackleIO::Util::sanitizeUserVisibleLetterString(QuackleIO::Util::moveToDetailedString(*it))).arg((*it).score);
				break;
			}

			case Quackle::Move::Exchange:
			case Quackle::Move::BlindExchange:
			default:
				item = QuackleIO::Util::moveToDetailedString(*it);
				break;
			}

			if (*it == position.committedMove())
				item += QString(" &nbsp;&larr;");

			if (!item.isEmpty())
				m_ostream << "<li>" << string(item.toUtf8().constData()) << "</li>" << endl;
		}
		m_ostream << "</ol>" << endl;
	}

	m_ostream << "\n\n";
}
